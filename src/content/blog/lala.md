---
title: 'ELOQUENT RELATIONSHIPS & WITH()'
code: 'laravel'
description: 'Gu√≠a Completa: C√≥mo Dominar las Relaciones'
pubDate: 'Jun 19 2024'
heroImage: '../../assets/blog-placeholder-1.jpg'
---

# üéØ ELOQUENT RELATIONSHIPS & WITH() 
## Gu√≠a Completa: C√≥mo Dominar las Relaciones

---

## ü§î **¬øPOR QU√â ES IMPORTANTE EL with()?**

### **El Problema N+1 (Sin with)**
```php
// ‚ùå PROBLEMA N+1 - GENERA M√öLTIPLES CONSULTAS
$posts = Post::all(); // 1 consulta

foreach ($posts as $post) {
    echo $post->user->name;     // +1 consulta por cada post
    echo $post->category->name; // +1 consulta por cada post
}

// Si tienes 100 posts = 1 + 100 + 100 = 201 consultas! üò±
```

### **La Soluci√≥n con with() (Eager Loading)**
```php
// ‚úÖ SOLUCI√ìN - SOLO 3 CONSULTAS
$posts = Post::with(['user', 'category'])->get(); // 3 consultas total

foreach ($posts as $post) {
    echo $post->user->name;     // Sin consultas adicionales
    echo $post->category->name; // Sin consultas adicionales
}

// 100 posts = 3 consultas totales! üöÄ
```

---

## ‚ö†Ô∏è **REGLA FUNDAMENTAL: ¬°NO PUEDES PONER CUALQUIER TABLA!**

### **üö´ ERROR COM√öN: Pensar que with() = Tablas de la BD**

```php
// ‚ùå ESTO NO FUNCIONA - No son relaciones definidas
Post::with(['users'])->get();      // Error: users no es una relaci√≥n de Post
Post::with(['categories'])->get(); // Error: categories no es una relaci√≥n de Post  
Post::with(['products'])->get();   // Error: products no existe como relaci√≥n
Post::with(['orders'])->get();     // Error: orders no tiene relaci√≥n con Post

// ü§î ¬øPor qu√© no funciona?
// Porque with() NO busca tablas, busca M√âTODOS DE RELACI√ìN en tu modelo
```

### **‚úÖ REGLA DE ORO: with() Solo Acepta Relaciones Definidas**

```php
// En app/Models/Post.php
class Post extends Model 
{
    // ‚úÖ ESTAS son las √∫nicas relaciones que puedes usar en with()
    public function user() {          // Puedes usar: 'user'
        return $this->belongsTo(User::class);
    }
    
    public function category() {      // Puedes usar: 'category'  
        return $this->belongsTo(Category::class);
    }
    
    public function tags() {          // Puedes usar: 'tags'
        return $this->belongsToMany(Tag::class);
    }
    
    // ‚ùå NO HAY relaci√≥n definida para 'products' o 'orders'
    // Por eso no puedes usarlas en with()
}

// ‚úÖ CORRECTO: Solo usar relaciones que existen
Post::with(['user', 'category', 'tags'])->get(); // ‚úÖ Funciona

// ‚ùå ERROR: Usar nombres que no son relaciones
Post::with(['products', 'users', 'orders'])->get(); // ‚ùå Falla
```

### **üîç DIFERENCIA CLAVE: Tabla vs Relaci√≥n**

| Concepto | Qu√© Es | Ejemplo | Se Usa En |
|----------|--------|---------|-----------|
| **Tabla** | Nombre en la base de datos | `users`, `posts`, `categories` | Consultas SQL directas |
| **Relaci√≥n** | M√©todo en tu modelo | `user()`, `category()`, `tags()` | `with()` de Eloquent |

```php
// üìä EN LA BASE DE DATOS tienes estas tablas:
// - users
// - posts  
// - categories
// - tags
// - post_tag (pivot)

// üîó EN TU MODELO Post tienes estas relaciones:
class Post extends Model {
    public function user()     {}  // Relaci√≥n: 'user' (no 'users')
    public function category() {}  // Relaci√≥n: 'category' (no 'categories') 
    public function tags()     {}  // Relaci√≥n: 'tags' (s√≠ coincide)
}

// ‚úÖ CORRECTO: Usar nombres de RELACIONES
Post::with(['user', 'category', 'tags'])->get();

// ‚ùå ERROR: Usar nombres de TABLAS  
Post::with(['users', 'categories', 'posts'])->get();
```

### **üéØ C√ìMO SABER QU√â PUEDES PONER EN with()**

#### **M√©todo 1: Lista las Relaciones de tu Modelo**
```php
// Revisa SOLO los m√©todos que retornan relaciones
class Post extends Model {
    // ‚úÖ Relaci√≥n - puedes usar 'user'
    public function user() {
        return $this->belongsTo(User::class);
    }
    
    // ‚úÖ Relaci√≥n - puedes usar 'comments'  
    public function comments() {
        return $this->hasMany(Comment::class);
    }
    
    // ‚ùå NO es relaci√≥n - es un scope
    public function scopePublished($query) {
        return $query->where('status', 'published');
    }
    
    // ‚ùå NO es relaci√≥n - es un accessor
    public function getFormattedDateAttribute() {
        return $this->created_at->format('Y-m-d');
    }
}

// ‚úÖ PUEDES USAR: 'user', 'comments'
// ‚ùå NO PUEDES USAR: 'published', 'formattedDate'
```

#### **M√©todo 2: Comando Tinker para Verificar**
```php
php artisan tinker

// Verificar si una relaci√≥n existe
>>> $post = App\Models\Post::first()
>>> method_exists($post, 'user')     // true = puedes usar 'user'
>>> method_exists($post, 'users')    // false = NO puedes usar 'users'
>>> method_exists($post, 'category') // true = puedes usar 'category'
>>> method_exists($post, 'products') // false = NO puedes usar 'products'

// Ver todas las relaciones disponibles
>>> collect(get_class_methods($post))
    ->filter(fn($method) => 
        !str_starts_with($method, 'get') && 
        !str_starts_with($method, 'set') &&
        !str_starts_with($method, 'scope')
    )->values()
```

### **üí° ¬øQU√â HACER SI NECESITAS UNA TABLA SIN RELACI√ìN?**

#### **Opci√≥n 1: Crear la Relaci√≥n (Recomendado)**
```php
// Si necesitas conectar Post con Product
class Post extends Model {
    // Crear nueva relaci√≥n
    public function relatedProducts() {
        return $this->belongsToMany(Product::class, 'post_product');
    }
}

// Crear migraci√≥n para tabla pivot
php artisan make:migration create_post_product_table

// Ahora S√ç puedes usar:
Post::with(['relatedProducts'])->get();
```

#### **Opci√≥n 2: Consulta Separada (Si no hay relaci√≥n l√≥gica)**
```php
// Si NO hay relaci√≥n l√≥gica entre Post y Product
$posts = Post::with(['user', 'category'])->get();
$products = Product::where('featured', true)->get();

// Manejar por separado en tu controlador/servicio
return [
    'posts' => $posts,
    'products' => $products
];
```

#### **Opci√≥n 3: Join Manual (Para casos espec√≠ficos)**
```php
// Si necesitas datos de tabla sin relaci√≥n formal
$posts = Post::join('some_table', 'posts.some_id', '=', 'some_table.id')
             ->select('posts.*', 'some_table.some_field')
             ->with(['user', 'category'])
             ->get();
```

### **üö® ERRORES T√çPICOS Y SUS SOLUCIONES**

#### **Error 1: Usar Nombre de Tabla en lugar de Relaci√≥n**
```php
// ‚ùå ERROR
Post::with(['users'])->get();
// Error: "Call to undefined relationship [users] on model [Post]"

// ‚úÖ SOLUCI√ìN: Usar el nombre de la relaci√≥n
Post::with(['user'])->get(); // 'user' es el m√©todo en el modelo
```

#### **Error 2: Inventar Relaciones que No Existen**
```php
// ‚ùå ERROR
User::with(['posts', 'orders', 'products'])->get();
// Si User no tiene relaci√≥n 'orders' o 'products' = Error

// ‚úÖ SOLUCI√ìN: Solo usar relaciones que existen
User::with(['posts'])->get(); // Solo si exists public function posts()
```

#### **Error 3: Confundir Plural/Singular**
```php
// En tu modelo User:
public function posts() {          // ‚úÖ M√©todo 'posts' (plural)
    return $this->hasMany(Post::class);
}

public function profile() {        // ‚úÖ M√©todo 'profile' (singular)  
    return $this->hasOne(Profile::class);
}

// ‚ùå ERRORES COMUNES
User::with(['post'])->get();      // Error: 'post' no existe, es 'posts'
User::with(['profiles'])->get();  // Error: 'profiles' no existe, es 'profile'

// ‚úÖ CORRECTO
User::with(['posts', 'profile'])->get();
```

### **üîç VERIFICACI√ìN R√ÅPIDA: ¬øPuedo Usar Esta Relaci√≥n?**

```php
// Pasos para verificar:

// 1. ¬øExiste el m√©todo en mi modelo?
class Post extends Model {
    public function user() { ... }     // ‚úÖ S√≠ = puedes usar 'user'
    // ¬øHay m√©todo products()? ‚ùå No = NO puedes usar 'products'
}

// 2. ¬øEl m√©todo retorna una relaci√≥n?
public function user() {
    return $this->belongsTo(User::class); // ‚úÖ S√≠ = es relaci√≥n v√°lida
}

public function getStatusAttribute() {
    return 'active'; // ‚ùå No = es accessor, no relaci√≥n
}

// 3. Probar en tinker
>>> Post::with(['user'])->first()     // ‚úÖ Funciona = relaci√≥n v√°lida
>>> Post::with(['products'])->first() // ‚ùå Error = relaci√≥n no existe
```

---

## üîç **C√ìMO IDENTIFICAR LAS RELACIONES DISPONIBLES**

### **M√©todo 1: Revisar el Modelo**
```php
// app/Models/Post.php
class Post extends Model
{
    // ‚úÖ Estas son las relaciones disponibles para with()
    public function user()     // Relaci√≥n: 'user'
    public function category() // Relaci√≥n: 'category'  
    public function tags()     // Relaci√≥n: 'tags'
    public function comments() // Relaci√≥n: 'comments'
    
    // ‚ùå Esto NO es una relaci√≥n (es un scope)
    public function scopePublished($query) // No usar en with()
}
```

### **M√©todo 2: Artisan Command para Ver Relaciones**
```bash
# Crear comando personalizado para inspeccionar modelo
php artisan make:command ShowModelRelations

# O usar tinker para explorar
php artisan tinker
>>> $post = App\Models\Post::first()
>>> $post->getRelations() // Ver relaciones cargadas
>>> collect(get_class_methods($post))->filter(function($method) {
    return method_exists($post, $method) && 
           !in_array($method, ['getRelations', 'getDirty', 'getChanges']);
})
```

### **M√©todo 3: Usar Laravel Debugbar**
```bash
# Instalar debugbar para ver consultas
composer require barryvdh/laravel-debugbar --dev
```

---

## üìö **SINTAXIS COMPLETA DEL with()**

### **1. Cargar Relaciones B√°sicas**
```php
// Cargar una relaci√≥n
Post::with('user')->get();

// Cargar m√∫ltiples relaciones
Post::with(['user', 'category', 'tags'])->get();

// Sintaxis alternativa (mismo resultado)
Post::with('user', 'category', 'tags')->get();
```

### **2. Seleccionar Campos Espec√≠ficos**
```php
// ‚úÖ SINTAXIS CORRECTA: 'relacion:campo1,campo2'
Post::with(['user:id,name,email', 'category:id,name'])->get();

// ‚ö†Ô∏è IMPORTANTE: Siempre incluir la clave for√°nea
// Si Post tiene 'user_id', debes incluir 'id' en user
Post::with(['user:id,name'])->get(); // ‚úÖ Incluye 'id'

// ‚ùå ERROR COM√öN: No incluir la clave primaria
Post::with(['user:name,email'])->get(); // ‚ùå Falta 'id'
```

### **3. Relaciones Anidadas (Nested)**
```php
// Cargar comentarios con sus usuarios
Post::with(['comments.user'])->get();

// M√∫ltiples niveles
Post::with(['comments.user.profile'])->get();

// Con selecci√≥n de campos en cada nivel
Post::with([
    'comments:id,post_id,user_id,content',
    'comments.user:id,name,avatar'
])->get();
```

### **4. Relaciones Condicionales**
```php
// Cargar solo comentarios aprobados
Post::with(['comments' => function($query) {
    $query->where('is_approved', true)
          ->orderBy('created_at', 'desc');
}])->get();

// Combinar condiciones con selecci√≥n de campos
Post::with([
    'comments' => function($query) {
        $query->select('id', 'post_id', 'user_id', 'content')
              ->where('is_approved', true)
              ->with('user:id,name,avatar');
    }
])->get();
```

---

## üîó **GU√çA POR TIPO DE RELACI√ìN**

### **ONE-TO-MANY (hasMany/belongsTo)**

```php
// Modelo User
class User extends Model 
{
    public function posts() {
        return $this->hasMany(Post::class);
    }
}

// Modelo Post  
class Post extends Model
{
    public function user() {
        return $this->belongsTo(User::class);
    }
}

// ‚úÖ USAR EN with()
// Desde User (hasMany)
User::with(['posts:id,user_id,title,slug'])->get();

// Desde Post (belongsTo)  
Post::with(['user:id,name,email'])->get();

// ‚ùå CLAVES FOR√ÅNEAS REQUERIDAS
User::with(['posts:title,slug'])->get();        // ‚ùå Falta 'id' y 'user_id'
Post::with(['user:name,email'])->get();         // ‚ùå Falta 'id'
```

### **MANY-TO-MANY (belongsToMany)**

```php
// Modelo Post
class Post extends Model
{
    public function tags() {
        return $this->belongsToMany(Tag::class);
    }
}

// Modelo Tag
class Tag extends Model  
{
    public function posts() {
        return $this->belongsToMany(Post::class);
    }
}

// ‚úÖ USAR EN with()
Post::with(['tags:id,name,slug'])->get();
Tag::with(['posts:id,title,slug'])->get();

// ‚úÖ Con datos de tabla pivot
Post::with(['tags:id,name'])->get();
// Acceder: $post->tags->first()->pivot->created_at

// ‚úÖ Con campos espec√≠ficos del pivot
class Post extends Model {
    public function tags() {
        return $this->belongsToMany(Tag::class)
                   ->withPivot('order', 'featured')
                   ->withTimestamps();
    }
}
```

### **SELF-RELATIONSHIP (Autoreferencia)**

```php
// Modelo Comment (comentarios anidados)
class Comment extends Model
{
    public function parent() {
        return $this->belongsTo(Comment::class, 'parent_id');
    }
    
    public function children() {
        return $this->hasMany(Comment::class, 'parent_id');
    }
}

// ‚úÖ USAR EN with()
// Cargar comentarios padre con sus hijos
Comment::with(['children:id,parent_id,content,user_id'])->get();

// Cargar comentario con su padre
Comment::with(['parent:id,content,user_id'])->get();

// Anidaci√≥n m√∫ltiple (cuidado con la profundidad)
Comment::with(['children.children'])->get();
```

---

## üéØ **EJEMPLOS PR√ÅCTICOS PASO A PASO**

### **Ejemplo 1: Blog Post Completo**

```php
// üìÑ Caso: Mostrar un post con toda su informaci√≥n

// ‚ùå FORMA INCORRECTA (M√∫ltiples consultas)
$post = Post::find(1);
$author = $post->user;              // +1 consulta
$category = $post->category;        // +1 consulta  
$tags = $post->tags;               // +1 consulta
$comments = $post->comments;        // +1 consulta
foreach ($comments as $comment) {
    $commentUser = $comment->user;  // +1 consulta por comentario
}

// ‚úÖ FORMA CORRECTA (1 sola consulta optimizada)
$post = Post::with([
    'user:id,name,email,avatar',
    'category:id,name,slug,color',
    'tags:id,name,slug',
    'comments:id,post_id,user_id,content,created_at',
    'comments.user:id,name,avatar'
])->find(1);

// Acceder a los datos (sin consultas adicionales)
echo $post->user->name;                    // ‚úÖ Ya cargado
echo $post->category->name;                // ‚úÖ Ya cargado  
foreach ($post->tags as $tag) {           // ‚úÖ Ya cargado
    echo $tag->name;
}
foreach ($post->comments as $comment) {    // ‚úÖ Ya cargado
    echo $comment->user->name;             // ‚úÖ Ya cargado
}
```

### **Ejemplo 2: Lista de Posts para Homepage**

```php
// üìÑ Caso: Mostrar lista de posts en homepage

$posts = Post::with([
    // Autor (solo datos necesarios para mostrar)
    'user:id,name,avatar',
    
    // Categor√≠a (solo para mostrar badge)  
    'category:id,name,color',
    
    // Tags (solo nombres para mostrar)
    'tags:id,name',
    
    // NO cargar comentarios completos, solo contar
])->withCount([
    'comments',              // Cuenta total
    'comments as approved_comments_count' => function($query) {
        $query->where('is_approved', true);
    }
])->published()
  ->latest()
  ->paginate(12);

// En la vista/API puedes acceder:
foreach ($posts as $post) {
    echo $post->user->name;                 // ‚úÖ Sin consulta adicional
    echo $post->category->name;             // ‚úÖ Sin consulta adicional
    echo $post->comments_count;             // ‚úÖ Ya calculado
    echo $post->approved_comments_count;    // ‚úÖ Ya calculado
}
```

### **Ejemplo 3: Comentarios Anidados**

```php
// üìÑ Caso: Sistema de comentarios con respuestas

$post = Post::with([
    // Comentarios padre (sin parent_id)
    'comments' => function($query) {
        $query->whereNull('parent_id')
              ->where('is_approved', true)
              ->orderBy('created_at', 'desc')
              ->select('id', 'post_id', 'user_id', 'content', 'created_at', 'parent_id');
    },
    
    // Usuario de cada comentario padre
    'comments.user:id,name,avatar',
    
    // Respuestas de cada comentario (hijos)
    'comments.children' => function($query) {
        $query->where('is_approved', true)
              ->orderBy('created_at', 'asc')
              ->select('id', 'post_id', 'user_id', 'content', 'created_at', 'parent_id');
    },
    
    // Usuario de cada respuesta
    'comments.children.user:id,name,avatar'
    
])->find(1);

// Estructura resultante:
/*
$post->comments (comentarios padre)
‚îú‚îÄ‚îÄ $comment->user (autor del comentario)
‚îî‚îÄ‚îÄ $comment->children (respuestas)
    ‚îî‚îÄ‚îÄ $reply->user (autor de la respuesta)
*/
```

---

## üõ†Ô∏è **HERRAMIENTAS PARA DEBUGGEAR**

### **1. Ver las Consultas SQL Generadas**

```php
// Activar log de consultas
\DB::enableQueryLog();

// Tu consulta con with()
$posts = Post::with(['user:id,name', 'category:id,name'])->get();

// Ver las consultas ejecutadas
dd(\DB::getQueryLog());

// Resultado t√≠pico:
/*
[
    {
        "query": "select * from posts",
        "bindings": [],
        "time": 1.23
    },
    {
        "query": "select id, name from users where id in (1, 2, 3, 4, 5)",
        "bindings": [],
        "time": 0.45
    },
    {
        "query": "select id, name from categories where id in (1, 2, 3)",
        "bindings": [],
        "time": 0.32
    }
]
*/
```

### **2. Usar toSql() para Ver Query**

```php
// Ver la consulta principal (sin ejecutar)
$query = Post::with(['user:id,name'])->toSql();
echo $query; // "select * from posts"

// Para ver las consultas de relaciones, usa explain
Post::with(['user:id,name'])->explain();
```

### **3. Comando Artisan para Inspeccionar Modelos**

```php
// Crear comando personalizado
// app/Console/Commands/InspectModel.php

<?php
namespace App\Console\Commands;

use Illuminate\Console\Command;
use ReflectionClass;
use ReflectionMethod;

class InspectModel extends Command
{
    protected $signature = 'model:inspect {model}';
    protected $description = 'Inspect model relationships';

    public function handle()
    {
        $modelClass = 'App\\Models\\' . $this->argument('model');
        
        if (!class_exists($modelClass)) {
            $this->error("Model {$modelClass} not found");
            return;
        }

        $reflection = new ReflectionClass($modelClass);
        $methods = $reflection->getMethods(ReflectionMethod::IS_PUBLIC);
        
        $relationships = [];
        
        foreach ($methods as $method) {
            if ($method->class === $modelClass && 
                !in_array($method->name, ['getRelations', 'relationResolver'])) {
                
                // Detectar si es una relaci√≥n leyendo el c√≥digo
                $source = file_get_contents($method->getFileName());
                $methodSource = $this->extractMethodSource($source, $method);
                
                if (preg_match('/return\s+\$this->(hasMany|belongsTo|hasOne|belongsToMany|morphTo|morphMany)/', $methodSource)) {
                    $relationships[] = $method->name;
                }
            }
        }
        
        $this->info("Relationships found in {$modelClass}:");
        foreach ($relationships as $relation) {
            $this->line("  - {$relation}");
        }
        
        // Ejemplo de uso
        $this->info("\nExample usage:");
        $modelName = class_basename($modelClass);
        $this->line("{$modelName}::with(['" . implode("', '", $relationships) . "'])->get();");
    }
    
    private function extractMethodSource($source, $method) {
        // Implementaci√≥n simplificada para extraer c√≥digo del m√©todo
        $lines = explode("\n", $source);
        $startLine = $method->getStartLine() - 1;
        $endLine = $method->getEndLine() - 1;
        
        return implode("\n", array_slice($lines, $startLine, $endLine - $startLine + 1));
    }
}
```

### **4. Usar Laravel Debugbar**

```bash
# Instalar
composer require barryvdh/laravel-debugbar --dev

# En .env
APP_DEBUG=true

# Ver√°s en el navegador:
# - N√∫mero de consultas ejecutadas
# - Tiempo de cada consulta  
# - Consultas duplicadas
# - Problemas N+1
```

---

## ‚ö†Ô∏è **ERRORES COMUNES Y SOLUCIONES**

### **Error 1: Olvidar Claves For√°neas**

```php
// ‚ùå ERROR: No incluir claves necesarias
Post::with(['user:name,email'])->get();

// Error: "Trying to get property 'name' of non-object"
// Causa: Falta 'id' en la selecci√≥n de user

// ‚úÖ SOLUCI√ìN: Siempre incluir claves primarias y for√°neas
Post::with(['user:id,name,email'])->get();

// üìù REGLA: Si Post tiene 'user_id', siempre incluir 'id' en user
```

### **Error 2: Sintaxis Incorrecta en Campos**

```php
// ‚ùå ERROR: Espacios en la sintaxis
Post::with(['user: id, name, email'])->get(); // Espacios despu√©s de ':'

// ‚úÖ CORRECTO: Sin espacios
Post::with(['user:id,name,email'])->get();
```

### **Error 3: Confundir Relaciones con Scopes**

```php
// En el modelo Post
public function scopePublished($query) {        // ‚ùå Esto es un SCOPE
    return $query->where('status', 'published');
}

public function user() {                        // ‚úÖ Esto es una RELACI√ìN
    return $this->belongsTo(User::class);
}

// ‚ùå ERROR: Usar scope en with()
Post::with(['published'])->get(); // No funciona

// ‚úÖ CORRECTO: Usar relaci√≥n en with()
Post::with(['user'])->get();      // Funciona
```

### **Error 4: Relaciones Anidadas Incorrectas**

```php
// ‚ùå ERROR: Sintaxis incorrecta para anidadas
Post::with(['comments', 'comments->user'])->get(); // Flecha incorrecta

// ‚úÖ CORRECTO: Usar punto para anidar
Post::with(['comments.user'])->get();
```

---

## üöÄ **T√âCNICAS AVANZADAS**

### **1. with() Condicional**

```php
// Cargar relaciones seg√∫n condiciones
$posts = Post::with([
    'user:id,name,avatar',
    'category:id,name,color'
])
->when($includeComments, function($query) {
    $query->with(['comments.user:id,name']);
})
->when($includeTags, function($query) {
    $query->with(['tags:id,name']);
})
->get();
```

### **2. withCount() para Optimizar**

```php
// En lugar de cargar todas las relaciones para contar
Post::with(['comments'])->get(); // Carga TODOS los comentarios

// Usar withCount() para solo obtener el n√∫mero
Post::withCount(['comments'])->get(); // Solo cuenta, no carga datos

// Combinar ambas t√©cnicas
Post::with(['user:id,name'])
    ->withCount([
        'comments',
        'comments as approved_comments_count' => function($query) {
            $query->where('is_approved', true);
        }
    ])
    ->get();
```

### **3. Lazy Loading Espec√≠fico**

```php
// Si ya tienes el modelo, cargar relaciones despu√©s
$post = Post::find(1);

// Cargar relaci√≥n espec√≠fica despu√©s
$post->load(['user:id,name', 'category:id,name']);

// Cargar solo si no est√° ya cargada
$post->loadMissing(['comments.user']);
```

### **4. Scopes Personalizados para with()**

```php
// En el modelo Post
public function scopeWithAuthorAndCategory($query)
{
    return $query->with([
        'user:id,name,avatar,bio',
        'category:id,name,slug,color'
    ]);
}

public function scopeWithBasicRelations($query)
{
    return $query->with([
        'user:id,name,avatar',
        'category:id,name',
    ])->withCount(['comments', 'views']);
}

// Uso
Post::withAuthorAndCategory()->get();
Post::withBasicRelations()->published()->latest()->get();
```

---

## üéØ **CHECKLIST DE BUENAS PR√ÅCTICAS**

### ‚úÖ **Antes de Usar with()**
- [ ] ¬øRealmente necesito estos datos?
- [ ] ¬øEstoy incluyendo las claves for√°neas necesarias?
- [ ] ¬øPuedo usar withCount() en lugar de cargar toda la relaci√≥n?
- [ ] ¬øEs m√°s eficiente lazy loading en este caso?

### ‚úÖ **Al Escribir with()**
- [ ] Incluir siempre la clave primaria (id)
- [ ] Incluir claves for√°neas necesarias
- [ ] No usar espacios en la sintaxis (:)
- [ ] Verificar que las relaciones existen en el modelo

### ‚úÖ **Optimizaci√≥n**
- [ ] Usar select solo los campos necesarios
- [ ] Combinar with() y withCount() inteligentemente
- [ ] Evitar cargar relaciones anidadas muy profundas
- [ ] Testear performance con Laravel Debugbar

### ‚úÖ **Testing**
- [ ] Verificar n√∫mero de consultas con enableQueryLog()
- [ ] Probar con datasets grandes
- [ ] Medir tiempo de respuesta
- [ ] Verificar que no hay problemas N+1

---

## üìñ **REFERENCIA R√ÅPIDA**

```php
// SINTAXIS B√ÅSICA
Model::with('relation')->get()
Model::with(['rel1', 'rel2'])->get()
Model::with('rel1', 'rel2')->get()

// CON CAMPOS ESPEC√çFICOS  
Model::with(['relation:id,field1,field2'])->get()

// ANIDADAS
Model::with(['rel1.rel2'])->get()
Model::with(['rel1.rel2:id,field'])->get()

// CONDICIONALES
Model::with(['rel' => function($q) {
    $q->where('field', 'value')->orderBy('field');
}])->get()

// CONTADORES
Model::withCount('relation')->get()
Model::withCount(['rel as custom_count' => function($q) {
    $q->where('condition', true);
}])->get()

// COMBINADAS
Model::with(['rel1:id,name'])
     ->withCount('rel2')
     ->where('active', true)
     ->get()
```

---

¬°Con esta gu√≠a dominar√°s completamente las relaciones de Eloquent y el uso del `with()`! üöÄ

**Pr√≥ximo paso recomendado:** Practicar con tu propio proyecto implementando estas t√©cnicas paso a paso.